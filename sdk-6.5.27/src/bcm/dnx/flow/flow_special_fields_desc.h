 /** \file flow_special_fields_desc.h
 *
 * All dnx flow internal structs, callbacks structures etc.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 *
 */

#pragma once

const char *
flow_special_field_fodo_assignment_mode_desc(
    int unit)
{
    return "How to get the VSI value, possible values FROM_VLAN / FROM_LIF / FROM_LOOKUP";
}

const char *
flow_special_field_pcp_dei_porf_desc(
    int unit)
{
    return "Set the QOS map profile that was generated by bcm_qos_map_add()";
}

const char *
flow_special_field_ipv4_dip_desc(
    int unit)
{
    return "Set the IPV4 header DIP field";
}

const char *
flow_special_field_ipv4_dip_mask_desc(
    int unit)
{
    return "Set the bits masking for IPV4 header DIP field";
}

const char *
flow_special_field_ipv4_sip_desc(
    int unit)
{
    return "Set the IPV4 header SIP field";
}

const char *
flow_special_field_ipv4_sip_mask_desc(
    int unit)
{
    return "Set the bits masking for IPV4 header SIP field";
}

const char *
flow_special_field_ipv6_dip_desc(
    int unit)
{
    return "Set the IPV6 header DIP field";
}

const char *
flow_special_field_ipv6_dip_mask_desc(
    int unit)
{
    return "Set the bits masking for IPV6 header DIP field";
}

const char *
flow_special_field_ipv6_sip_desc(
    int unit)
{
    return "Set the IPV6 header SIP field";
}

const char *
flow_special_field_ipv6_sip_mask_desc(
    int unit)
{
    return "Set the bits masking for IPV6 header SIP field";
}

const char *
flow_special_field_src_mac_address_desc(
    int unit)
{
    return "Set the source MAC address";
}

const char *
flow_special_field_dst_mac_address_desc(
    int unit)
{
    return "Set the destination MAC address";
}

const char *
flow_special_field_vrf_desc(
    int unit)
{
    return "Set the virtual routing and forwarding (VRF) ID";
}

const char *
flow_special_field_vsi_desc(
    int unit)
{
    return "Set the virtual switch instance (VSI) ID";
}

const char *
flow_special_field_vni_desc(
    int unit)
{
    return "Set the virtual network identifier (VNI)";
}

const char *
flow_special_field_udp_src_desc(
    int unit)
{
    return "Set the UDP header source port";
}

const char *
flow_special_field_udp_dst_desc(
    int unit)
{
    return "Set the UDP header destination port";
}

const char *
flow_special_field_hdr_df_desc(
    int unit)
{
    return "enables and disables the IPV4 header defragmentation";
}

const char *
flow_special_field_ipv4_tunnel_desc(
    int unit)
{
    return
        "IPv4 Tunnel type, legal values are taken from bcm_tunnel_type_t. For Lif application value cannot be changed in replace.";
}

const char *
flow_special_field_ipv6_tunnel_desc(
    int unit)
{
    return "IPv6 Tunnel type, legal values are taken from bcm_tunnel_type_t";
}

const char *
flow_special_field_ipvx_tunnel_desc(
    int unit)
{
    return "IPvX Tunnel type, legal values are taken from bcm_tunnel_type_t";
}
const char *
flow_special_field_qos_pcp_desc(
    int unit)
{
    return "Sets OAM PCP profile";
}
const char *
flow_special_field_qos_desc(
    int unit)
{
    return "sets QoS info, require the setting of the common field BCM_FLOW_INITIATOR_ELEMENT_QOS_EGRESS_MODEL_VALID";
}

const char *
flow_special_field_mpls_port_vccv_type_desc(
    int unit)
{
    return "Legal values are mpls port types taken from bcm_mpls_port_control_channel_type_t";
}

const char *
flow_special_field_tunnel_init_flags_desc(
    int unit)
{
    return
        "IPv4 Tunnel initiator flags, mapping according to BCM_TUNNEL_INIT flags.\nField can only be set when setting IPV4_TUNNEL_TYPE.\nCan only set flags matching the matching tunnel_type";
}

const char *
flow_special_field_rch_type_desc(
    int unit)
{
    return "L2 Egress recycle Apps.";
}

const char *
flow_special_field_gtp_ext_ssn_type_desc(
    int unit)
{
    return "sets GTP extension header session container type: 0 or 1";
}

const char *
flow_special_field_gtp_ssn_rqi_desc(
    int unit)
{
    return "sets GTP session container extension header RQI: true or false";
}

const char *
flow_special_field_gtp_ext_header_type_desc(
    int unit)
{
    return "sets GTP session container extension header type: 0 (none) or 1(4B)";
}

const char *
flow_special_field_mpls_php_desc(
    int unit)
{
    return "Enabler indicating if tunnel is PHP.";
}

const char *
flow_special_field_mpls_label_desc(
    int unit)
{
    return "Value of mpls label 1.";
}

const char *
flow_special_field_mpls_label_2_desc(
    int unit)
{
    return "Value of mpls label 2.";
}

const char *
flow_special_field_mpls_label_3_desc(
    int unit)
{
    return "Value of mpls label 3.";
}

const char *
flow_special_field_mpls_label_4_desc(
    int unit)
{
    return "Value of mpls label 4.";
}

const char *
flow_special_field_mpls_label_5_desc(
    int unit)
{
    return "Value of mpls label 5.";
}

const char *
flow_special_field_mpls_label_6_desc(
    int unit)
{
    return "Value of mpls label 6.";
}

const char *
flow_special_field_mpls_label_7_desc(
    int unit)
{
    return "Value of mpls label 7.";
}

const char *
flow_special_field_mpls_label_8_desc(
    int unit)
{
    return "Value of mpls label 8.";
}

const char *
flow_special_field_mpls_entropy_label_desc(
    int unit)
{
    return "Enabler indicating that entropy label is present.";
}

const char *
flow_special_field_mpls_entropy_label_indication_desc(
    int unit)
{
    return "Enabler indicating that entropy label indicator is present.";
}

const char *
flow_special_field_mpls_control_word_enable_desc(
    int unit)
{
    return "Enabler indicating that control word label is present.";
}

const char *
flow_special_field_mpls_platform_namespace_desc(
    int unit)
{
    return "Enabler indicating whether the LIF is NAMESPACE.";
}

const char *
flow_special_field_mpls_inclusive_multicast_label_desc(
    int unit)
{
    return "Enabler indicating whether IML label is expected.";
}

const char *
flow_special_field_mpls_nof_service_tags_desc(
    int unit)
{
    return "Number of tags included in the tagged tunnel.";
}

const char *
flow_special_field_mpls_expect_bos_desc(
    int unit)
{
    return "Enabler indicating whether the terminated tunnel expected to be BOS.";
}

const char *
flow_special_field_mpls_expect_non_bos_desc(
    int unit)
{
    return "Enabler indicating whether the terminated tunnel expected not to be BOS.";
}

const char *
flow_special_field_mpls_trap_ttl_0_desc(
    int unit)
{
    return "Enabler indicating whether to enable trap in case TTL is 0.";
}

const char *
flow_special_field_mpls_trap_ttl_1_desc(
    int unit)
{
    return "Enabler indicating whether to enable trap in case TTL is 1.";
}

const char *
flow_special_field_match_label_desc(
    int unit)
{
    return "Enabler indicating that termination tunnel should be matched on label value.";
}

const char *
flow_special_field_bier_desc(
    int unit)
{
    return "sets BIER header field info, defined in RFC 8296";
}

const char *
flow_special_field_ipv6_doh_desc(
    int unit)
{
    return "set IPv6 DOH extenssion header, present status or header information";
}
